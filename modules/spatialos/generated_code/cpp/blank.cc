// Generated by SpatialOS codegen. DO NOT EDIT!
// source: blank.schema
#include "blank.h"

namespace sample {

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_BlankData(const ::sample::BlankData&, ::worker::detail::internal::Pbio_Object*) {}

::sample::BlankData Read_BlankData(::worker::detail::internal::Pbio_Object*) {
  return {};
}

namespace {

void VtableFree_Blank(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::sample::Blank::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::sample::BlankData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Blank >::free(handle);
  }
}

void* VtableCopy_Blank(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::sample::Blank::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::sample::BlankData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Blank >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Blank(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::sample::Blank::Update >::allocate();
    {
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::sample::BlankData >::allocate(::sample::detail::Read_BlankData(::worker::detail::internal::Pbio_GetObject(root, 1001)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Blank(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    {
      ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 1001);
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::sample::detail::Write_BlankData(
        ::worker::detail::ClientHandle< ::sample::BlankData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 1001));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 1001);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 1001);
  }
}

}  // anonymous namespace

}  // ::detail

// Implementation of BlankData.
//----------------------------------------------------------------

BlankData::BlankData() {}

bool BlankData::operator==(const BlankData&) const {
  return true;
}

bool BlankData::operator!=(const BlankData& value) const {
  return !operator==(value);
}

// Implementation of Blank.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Blank::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Blank::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      1001,
      nullptr,
      &::sample::detail::VtableFree_Blank,
      &::sample::detail::VtableCopy_Blank,
      &::sample::detail::VtableDeserialize_Blank,
      &::sample::detail::VtableSerialize_Blank,
  };
  return vtable;
}

bool Blank::Update::operator==(const Blank::Update&) const {
  return true;
}

bool Blank::Update::operator!=(const Blank::Update& value) const {
  return !operator==(value);
}

Blank::Update Blank::Update::FromInitialData(const ::sample::BlankData&) {
  return Blank::Update{};
}

::sample::BlankData Blank::Update::ToInitialData() const {
  return ::sample::BlankData();
}

void Blank::Update::ApplyTo(::sample::BlankData&) const {
}

}  // ::sample

std::size_t std::hash< ::sample::BlankData >::operator()(const ::sample::BlankData& ) const {
  size_t result = 1327;
  return result;
}
